{"version":3,"sources":["phrasebook/TargetPicker.js","phrasebook/DamageTypePicker.js","Utils.js","phrasebook/PhraseTemplate.js","phrasebook/ConditionPicker.js","phrasebook/ProjectilePicker.js","phrasebook/FullPhrasePicker.js","movingparts/DrawTrial.js","common/Errorbar.js","common/ErrorGroup.js","movingparts/Spiral.js","movingparts/Agents.js","App.js","serviceWorker.js","index.js"],"names":["POSSIBLE_TARGETS","DAMAGE_TYPE","randomInt","max","Math","floor","random","randomIntEitherSign","randomIntOmitting","omit","chosenTemplate","uniformBaseGenerator","pointsToGen","varFunction","heightmax","widthmax","newCoords","ptsPerSide","ceil","sqrt","ystep","round","xstep","i","j","push","x","y","PhraseTemplate","props","state","templateId","pickRandomTemplate","bind","getTemplateFragment","getTopLevelFragment","setTemplateIdInRange","this","avoidPrevious","cachedId","setState","utils","template","length","targetIndex","sourceList","generatedFragment","canBeRerolled","className","onClick","id","isTop","React","Component","CONDITIONAL","PROJECTILE","TEMPLATES","DrawTrial","pts","radius","speed","accel","handleRadiusUpdate","handlePointCountUpdate","handleSpeedUpdate","handleAccelUpdate","timeId","cachedCanvas","coords","setInterval","tick","initCoords","clearInterval","e","target","value","document","getElementById","canvas","getContext","cnx","draw","updateCoords","updateV","canvasContext","clearRect","toDraw","save","fillStyle","translate","fillRect","restore","toUpdate","xv","xa","yv","ya","hitx","xvdec","hity","yvdec","intPartXv","intPartYv","potentialXdec","potentialYdec","extraEarnedX","abs","extraEarnedY","sign","CANVAS_WIDTH","CANVAS_HEIGHT","curOffset","radialStep","PI","newCoord","getCoordFromCentre","randomVariance","newV","getNormalizedOutwardV","xcen","ycen","radialOffset","cos","sin","width","height","type","min","onChange","htmlFor","step","Errorbar","errorstring","errorstr","ErrorGroup","errfragment","errorList","map","lsterrorstr","key","PTS_GENERATORS","uniform","uniformVar","SCALE_CONDITIONS","precondition","validate","input","Number","isNaN","parseFloat","errmsg","postcondition","ANGLE_CONDITIONS","Spiral","pointdist","angulardelta","scale","handleDistUpdate","handleAngleUpdate","handleScaleUpdate","handleDrawing","inputIssues","Set","currentDelta","currentScale","origcoords","actualAngle","checkForInputIssuesAndUpdate","actualScale","preCond","postCond","inputOp","defaultValue","handleAndFlagIssues","tempResult","criteria","hasFailed","add","delete","clearCanvas","getCachedCanvas","clear","rotate","disabled","size","coordsToCoordsWithVelocity","baseCoord","Agents","attrepthreshold","attrepforce","MAX_SPEED","handleAttRepThresholdUpdate","handleAttRepForceUpdate","otherCoord","slice","splice","forces","forceApplied","xapplied","yapplied","otherCoords","currentcoord","currentXApplied","currentYApplied","coord","xdelta","ydelta","distsqrd","pow","magnitude","logistic","angleRep","atan","xdirection","ydirection","console","log","exp","LOGISTIC_MIDPOINT","ApplicationPicker","active","pickActiveApp","nextApp","previousApp","applications","newActive","title","content","description","agent","spiral","drawTrial","abilityGen","appPicker","App","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.6d55ac19.chunk.js","sourcesContent":["const POSSIBLE_TARGETS = [\n    \"allies\",\n    \"enemies\",\n    \"all units\"\n];\n\nexport default POSSIBLE_TARGETS;","const DAMAGE_TYPE = [\n    \"slashing\",\n    \"blunt\",\n    \"piercing\",\n    \"mind\",\n    \"fire\",\n    \"earth\",\n    \"water\",\n    \"air\",\n    \"poison\"\n];\n\nexport default DAMAGE_TYPE;","export function pickSafely(targetIndex, sourceList) {\n    return targetIndex < sourceList.length \n    ? sourceList[targetIndex]\n    : '???'\n}\n  \nexport function randomInt(max) {\n    return Math.floor(Math.random() * Math.floor(max));\n}\n\n/**\n * \n * @param {number} max maximum in either positive or negative direction\n */\nexport function randomIntEitherSign(max) {\n    return randomInt(2) > 0 ? randomInt(max) : - randomInt(max);\n}\n\n/**\n * \n * @param {number} omit omitted index when randomizing. Negatives mean do not omit\n * @param {number} max non inclusive maximum\n */\nexport function randomIntOmitting(omit, max) {\n    if (omit < 0) {\n        return randomInt(max);\n    }\n    let chosenTemplate = randomInt(max - 1);\n    return chosenTemplate >= omit ? chosenTemplate + 1: chosenTemplate;\n}\n\n// varFunction should take the step for that dimension, then return some offset amount\nexport function uniformBaseGenerator(pointsToGen, varFunction, heightmax, widthmax) {\n    let newCoords = [];\n    // premature optimization is the root of all evil; but this can probably be better\n    let ptsPerSide = Math.ceil(Math.sqrt(pointsToGen));\n    let ystep = Math.round(heightmax / ptsPerSide);\n    let xstep = Math.round(widthmax / ptsPerSide);\n    for (let i = 0; i < ptsPerSide; i++) {\n      for (let j = 0; j < ptsPerSide; j++) {\n        newCoords.push({\n          x: xstep * i + Math.round(xstep / 2) + varFunction(xstep),\n          y: ystep * j + Math.round(ystep / 2) + varFunction(ystep)\n        });\n      }\n    }\n    return newCoords;\n  }","import React from 'react';\nimport * as utils from '../Utils.js';\n\n/**\n * template prop defines the phrase list to use\n * isTop prop defines whether the phrase should be rendered with wrappings\n * canBeRerolled defines whether it should be clickable to reroll\n */\nclass PhraseTemplate extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {templateId: -1};\n    this.pickRandomTemplate = this.pickRandomTemplate.bind(this);\n    this.getTemplateFragment = this.getTemplateFragment.bind(this);\n    this.getTopLevelFragment = this.getTopLevelFragment.bind(this);\n    this.setTemplateIdInRange = this.setTemplateIdInRange.bind(this);\n  }\n\n  componentDidMount() {\n    this.pickRandomTemplate();\n  }\n\n  /**\n   * Pick a random valid template\n   * @param {boolean} avoidPrevious  avoid the previous template to 'feel' more random\n   */\n  pickRandomTemplate(avoidPrevious) {\n    let cachedId = avoidPrevious ?\n    this.state.templateId :\n    -1\n    // to ensure children get randomized, blank this out first to force remounting TODO is there a better way?\n    this.setState(() => {\n      return {templateId : -1};\n    }, () => this.setTemplateIdInRange(cachedId));\n  }\n\n  /**\n   * Set template id to a random valid one that is not the given\n   * @param {number} cachedId id to omit, negatives mean do not omit\n   */\n  setTemplateIdInRange(cachedId) {\n    this.setState((state, props) => {\n      return {templateId : utils.randomIntOmitting(cachedId, props.template.length)};\n    });\n  }\n\n  getTemplateFragment() {\n    let generatedFragment = this.state.templateId === -1 ?\n      <></> :\n      <>{utils.pickSafely(this.state.templateId, this.props.template)}</>\n    ;\n\n    if (this.props.canBeRerolled) {\n      generatedFragment = <div className=\"rerollable\" onClick={() => this.pickRandomTemplate(true)}>{generatedFragment}</div>;\n    }\n\n    return (\n      generatedFragment\n    )\n  }\n\n  getTopLevelFragment() {\n    return (\n      <div id=\"content-main\">\n        <div className=\"text-content\">\n          {this.getTemplateFragment()}\n        </div>\n        <button className=\"btn\" onClick={() => this.pickRandomTemplate(false)}>Another One!</button>\n      </div>\n    )\n  }\n\n  render() {\n    let generatedFragment = this.props.isTop ?\n      this.getTopLevelFragment() :\n      <div className=\"nested-phrase\">{this.getTemplateFragment()}</div>\n    ;\n    \n    return (\n      <>{generatedFragment}</>\n    )\n  }\n}\n\nexport default PhraseTemplate;\n","import React from 'react';\nimport DAMAGE_TYPE from './DamageTypePicker.js'\nimport PhraseTemplate from './PhraseTemplate.js'\n\nconst CONDITIONAL = [\n    <>\n      <PhraseTemplate isTop={false} template={DAMAGE_TYPE} canBeRerolled={true}/>\n      damage was recently taken by the caster\n    </>,\n    <>  \n      it is daytime\n    </>,\n    <>  \n      it is nighttime\n  </>\n  ];\n\nexport default CONDITIONAL;","const PROJECTILE = [\n    \"bolt\",\n    \"missile\",\n    \"shard\",\n    \"blob\",\n    \"bullet\",\n    \"blade\"\n];\n\nexport default PROJECTILE;","import React from 'react';\nimport POSSIBLE_TARGETS from './TargetPicker.js'\nimport DAMAGE_TYPE from './DamageTypePicker.js'\nimport CONDITIONAL from './ConditionPicker.js'\nimport PROJECTILE from './ProjectilePicker.js'\nimport PhraseTemplate from './PhraseTemplate.js'\n\nconst TEMPLATES = [\n    <div className=\"ability-content\">\n      Launch a\n      <PhraseTemplate isTop={false} template={PROJECTILE} canBeRerolled={true}/>\n      at\n      <PhraseTemplate isTop={false} template={POSSIBLE_TARGETS} canBeRerolled={true}/>\n      nearby that deals\n      <PhraseTemplate isTop={false} template={DAMAGE_TYPE} canBeRerolled={true}/>\n      damage\n    </div>,\n    <div className=\"ability-content\">\n      Launch a\n      <PhraseTemplate isTop={false} template={PROJECTILE} canBeRerolled={true}/>\n      that deals\n      <PhraseTemplate isTop={false} template={DAMAGE_TYPE} canBeRerolled={true}/> \n      damage.\n      Only usable if\n      <PhraseTemplate isTop={false} template={CONDITIONAL} canBeRerolled={false}/>\n    </div>,\n    <div className=\"ability-content\">\n    Release a\n    <PhraseTemplate isTop={false} template={PROJECTILE} canBeRerolled={true}/>\n    that deals\n    <PhraseTemplate isTop={false} template={DAMAGE_TYPE} canBeRerolled={true}/> \n    damage in a random direction.\n  </div>\n  ];\n\nexport default TEMPLATES;","import React from 'react';\nimport * as utils from '../Utils.js';\nimport '../style/drawtrial.css';\nimport '../style/commondraw.css';\n\nconst CANVASID = \"drawtrial-canvas\"\nconst CANVAS_WIDTH = 512;\nconst CANVAS_HEIGHT = 512;\nconst OBJ_WIDTH = 8;\nconst OBJ_HEIGHT = 8;\nconst MAX_POINTS_ALLOWED = 128;\nconst MAX_SPEED = 10;\nconst ACCEL_RANGE = 0.5;\n\nclass DrawTrial extends React.Component {\n  constructor(props) {\n    super(props);\n    // canvas can handle most things on its own\n    this.state = {\n      pts: 8,\n      radius: 20,\n      speed: 1,\n      accel: 0\n    };\n    this.handleRadiusUpdate = this.handleRadiusUpdate.bind(this);\n    this.handlePointCountUpdate = this.handlePointCountUpdate.bind(this);\n    this.handleSpeedUpdate = this.handleSpeedUpdate.bind(this);\n    this.handleAccelUpdate = this.handleAccelUpdate.bind(this);\n    this.timeId = -1;\n    this.cachedCanvas = null;\n    this.coords = [];\n  }\n\n  componentDidMount() {\n    this.timeId = setInterval(\n      () => this.tick(),\n      50\n    );\n    this.initCoords();\n  }\n\n  componentDidUpdate() {\n    this.initCoords();\n  }\n\n  componentWillUnmount() {\n    clearInterval(this.timeId);\n  }\n\n  handleRadiusUpdate(e) {\n    this.setState({radius: e.target.value});\n  }\n\n  handlePointCountUpdate(e) {\n    this.setState({pts: e.target.value});\n  }\n\n  handleSpeedUpdate(e) {\n    this.setState({speed: e.target.value});\n  }\n\n  handleAccelUpdate(e) {\n    this.setState({accel: e.target.value});\n  }\n\n  tick() {\n    if (!this.cachedCanvas) {\n      this.cachedCanvas = document.getElementById(CANVASID);\n    }\n\n    let canvas = this.cachedCanvas;\n    if (canvas.getContext) {\n      let cnx = canvas.getContext('2d');\n      this.draw(cnx);\n      this.updateCoords();\n      this.updateV();\n    }\n  }\n\n  draw(canvasContext) {\n    canvasContext.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n    for (let toDraw of this.coords) {\n      canvasContext.save();\n      canvasContext.fillStyle = \n        'rgb(' + (toDraw.y % 255)  + ', 0, 100, 100)';\n      canvasContext.translate(toDraw.x, toDraw.y);\n      canvasContext.fillRect(0, 0, OBJ_WIDTH, OBJ_HEIGHT);\n      canvasContext.restore();\n    }\n  }\n\n  updateV() {\n    for (let toUpdate of this.coords) {\n      toUpdate.xv += toUpdate.xv + toUpdate.xa > MAX_SPEED ? 0 : toUpdate.xa;\n      toUpdate.yv += toUpdate.yv + toUpdate.ya > MAX_SPEED ? 0 : toUpdate.ya;\n      // bounces\n      if (toUpdate.hitx) {\n        toUpdate.xv = - toUpdate.xv;\n        toUpdate.xvdec = - toUpdate.xvdec;\n        toUpdate.xa = - toUpdate.xa;\n        toUpdate.hitx = false;\n      }\n\n      if (toUpdate.hity) {\n        toUpdate.yv = - toUpdate.yv\n        toUpdate.yvdec = - toUpdate.yvdec;\n        toUpdate.ya = - toUpdate.ya;\n        toUpdate.hity = false;\n      }\n    }\n  }\n\n  updateCoords() {\n    for (let toUpdate of this.coords) {\n      // roundoff x and y and store the decimal part toward an extra pixel of movement\n      let intPartXv = toUpdate.xv > 0 ? Math.floor(toUpdate.xv) : Math.ceil(toUpdate.xv);\n      let intPartYv = toUpdate.yv > 0 ? Math.floor(toUpdate.yv) : Math.ceil(toUpdate.yv);\n      // TODO make this pretty\n      let potentialXdec = toUpdate.xvdec + (toUpdate.xv - intPartXv)\n      let potentialYdec = toUpdate.yvdec + (toUpdate.yv - intPartYv)\n      let extraEarnedX = Math.abs(potentialXdec) >= 1;\n      let extraEarnedY = Math.abs(potentialYdec) >= 1;\n      // if an extra pixel is 'spent', reduce back to decimal parts\n      toUpdate.xvdec = extraEarnedX ? potentialXdec - Math.sign(potentialXdec): potentialXdec;\n      toUpdate.yvdec = extraEarnedY ? potentialYdec - Math.sign(potentialYdec): potentialYdec;\n\n      // handle movement including partial movement\n      toUpdate.x += intPartXv + (extraEarnedX ? Math.sign(potentialXdec) : 0);\n      toUpdate.y += intPartYv + (extraEarnedY ? Math.sign(potentialYdec) : 0);\n\n      // bounces\n      if (toUpdate.x > CANVAS_WIDTH - OBJ_WIDTH) {\n        toUpdate.x = CANVAS_WIDTH - OBJ_WIDTH;\n        toUpdate.hitx = true;\n      } else if (toUpdate.x < 0) {\n        toUpdate.x = 0;\n        toUpdate.hitx = true;\n      }\n\n      if (toUpdate.y > CANVAS_HEIGHT - OBJ_HEIGHT) {\n        toUpdate.y = CANVAS_HEIGHT - OBJ_HEIGHT;\n        toUpdate.hity = true;\n      } else if (toUpdate.y < 0) {\n        toUpdate.y = 0;\n        toUpdate.hity = true;\n      }\n    }\n  }\n\n  initCoords() {\n    let canvasCenX = CANVAS_WIDTH / 2;\n    let canvasCenY = CANVAS_HEIGHT / 2;\n    let curOffset = 0;\n    let radialStep = (2 * Math.PI) / this.state.pts;\n    let newCoords = [];\n\n    for (let i = 0; i < this.state.pts; i++) {\n      let newCoord = this.getCoordFromCentre(canvasCenX, canvasCenY, curOffset, this.state.radius);\n      // up to pi / 4 either way\n      let randomVariance = utils.randomInt(2) > 0 ? utils.randomInt(9) * Math.PI / 32 : -utils.randomInt(9) * Math.PI / 32;\n      let newV = this.getNormalizedOutwardV(curOffset + randomVariance);\n\n      newCoords.push({\n        x: newCoord.x,\n        y: newCoord.y,\n        xv: newV.xv * this.state.speed, \n        yv: newV.yv * this.state.speed,\n        xvdec:0,\n        yvdec:0,\n        xa: newV.xv * this.state.accel,\n        ya: newV.yv * this.state.accel,\n        hitx: false,\n        hity: false\n      });\n      curOffset += radialStep;\n    }\n    this.coords = newCoords;\n  }\n\n  getCoordFromCentre(xcen, ycen, radialOffset, radius) {\n     let xdelta = radius * Math.cos(radialOffset);\n     let ydelta = radius * Math.sin(radialOffset);\n     let xfinal = xcen + xdelta;\n     let yfinal = ycen + ydelta;\n     return {x: xfinal, y: yfinal}\n  }\n  \n  getNormalizedOutwardV(radialOffset) {\n    let xdelta = Math.cos(radialOffset);\n    let ydelta = Math.sin(radialOffset);\n    return {xv: xdelta, yv: ydelta}\n  }\n\n  render() {\n    return (\n      <div className=\"canvas-container\">\n        <canvas id={CANVASID} width={CANVAS_WIDTH} height={CANVAS_HEIGHT}>\n          Canvas appears to be unsupported :(\n        </canvas>\n        <div id=\"canvas-controls\">\n          <input type=\"range\" id=\"radius\" min=\"0\" max={CANVAS_WIDTH / 2 - 20} onChange={this.handleRadiusUpdate}/>\n          <label htmlFor =\"radius\">Radius</label>\n          <input type=\"range\" id=\"points\" min=\"1\" max={MAX_POINTS_ALLOWED} onChange={this.handlePointCountUpdate}/>\n          <label htmlFor =\"points\">Number of Points</label>\n          <input type=\"range\" id=\"speed\" min={-MAX_SPEED} max={MAX_SPEED} step=\"0.1\" onChange={this.handleSpeedUpdate}/>\n          <label htmlFor =\"speed\">Speed</label>\n          <input type=\"range\" id=\"accel\" min={-ACCEL_RANGE} max={ACCEL_RANGE} step=\"0.1\" onChange={this.handleAccelUpdate}/>\n          <label htmlFor =\"accel\">Acceleration</label>\n        </div>\n      </div>\n    )\n  }\n}\n\nexport default DrawTrial;","import React from 'react';\nimport '../style/commondraw.css';\n\n/**\n * Represent a single error notification.\n * should be able to get error via props.errorstr\n */\nclass Errorbar extends React.Component {\n  render() {\n    const errorstring = this.props.errorstr;\n    return (\n      <>\n        {errorstring &&\n          <div className=\"error-inform\">{errorstring}</div>\n        }\n      </>\n    )\n  }\n}\n\nexport default Errorbar;","import React from 'react';\nimport Errorbar from './Errorbar.js';\n\n/**\n * Represent an error notification group.\n * should be able to get error list (list where each entry is an error string)\n *  via props.errorlist\n */\nclass ErrorGroup extends React.Component {\n  render() {\n    const errorList = this.props.errorList;\n    // hopefully unique\n    let errfragment = errorList.map((lsterrorstr) =>\n      <Errorbar key={\"key\" + lsterrorstr} errorstr={lsterrorstr}/>\n    );\n    return (\n      <>\n        {errfragment.length > 0 &&\n          <div className=\"error-grouper\">\n            {errfragment}\n          </div>\n        }\n      </>\n    )\n  }\n}\n\nexport default ErrorGroup;","import React from 'react';\nimport * as utils from '../Utils.js';\nimport '../style/spiral.css';\nimport '../style/commondraw.css';\nimport '../common/ErrorGroup.js'\nimport ErrorGroup from '../common/ErrorGroup.js';\n\nconst CANVASID = \"spiral-canvas\"\nconst CANVAS_WIDTH = 512;\nconst CANVAS_HEIGHT = 512;\nconst OBJ_WIDTH = 2;\nconst OBJ_HEIGHT = 2;\nconst MAX_POINTS_ALLOWED = 2048;\n// maybe use a map instead?\nconst PTS_GENERATORS = {\n  random: randGenerator,\n  uniform: uniformGenerator,\n  uniformVar : uniformGeneratorWithVariance\n}\nconst SCALE_CONDITIONS = {\n  precondition : {\n    validate : (input) => Number.isNaN(parseFloat(input)),\n    errmsg : \"Value given for scaling factor isn't a number\"\n  },\n  postcondition : {\n    validate : (input) => input === 0 || Math.abs(input) > 10,\n    errmsg : \"You aren't going to see anything with that scaling factor\"\n  }\n}\n\nconst ANGLE_CONDITIONS = {\n  precondition : {\n    validate : (input) => Number.isNaN(parseFloat(input)),\n    errmsg : \"Value given for angle isn't a number\"\n  },\n  postcondition : {\n    validate : (input) => Math.abs(input) > 2 * Math.PI,\n    errmsg : \"You don't need to be using that large an angle\"\n  }\n}\n\nfunction randGenerator(pointsToGen) {\n  let newCoords = [];\n  for (let i = 0; i < pointsToGen; i++) {\n    newCoords.push({\n      x: utils.randomInt(CANVAS_WIDTH - OBJ_WIDTH),\n      y: utils.randomInt(CANVAS_HEIGHT - OBJ_HEIGHT)\n    });\n  }\n  return newCoords;\n}\n\nfunction uniformGenerator(pointsToGen) {\n  return utils.uniformBaseGenerator(pointsToGen, (step) => 0,\n   CANVAS_HEIGHT, CANVAS_WIDTH);\n}\n\nfunction uniformGeneratorWithVariance(pointsToGen) {\n  return utils.uniformBaseGenerator(pointsToGen, (step) => utils.randomIntEitherSign(step/2),\n   CANVAS_HEIGHT, CANVAS_WIDTH);\n}\n\nclass Spiral extends React.Component {\n  constructor(props) {\n    super(props);\n    // canvas can handle most things on its own\n    this.state = {\n      pointdist: 'random',\n      pts: 8,\n      angulardelta: Math.PI/128,\n      scale: 1\n    };\n    this.handleDistUpdate = this.handleDistUpdate.bind(this);\n    this.handlePointCountUpdate = this.handlePointCountUpdate.bind(this);\n    this.handleAngleUpdate = this.handleAngleUpdate.bind(this);\n    this.handleScaleUpdate = this.handleScaleUpdate.bind(this);\n    this.handleDrawing = this.handleDrawing.bind(this);\n    this.cachedCanvas = null;\n    // just using straight strings for now. \n    // Will need to change if we ever want dynamic messages\n    this.inputIssues = new Set();\n    this.currentDelta = 0;\n    this.currentScale = 1;\n    this.origcoords = [];\n  }\n\n  componentDidMount() {\n    this.initCoords();\n  }\n\n  componentDidUpdate() {\n    this.initCoords();\n  }\n\n  handleDistUpdate(e) {\n    this.setState({pointdist: e.target.value});\n  }\n\n  handlePointCountUpdate(e) {\n    this.setState({pts: e.target.value});\n  }\n\n  handleAngleUpdate(e) {\n    let actualAngle = this.checkForInputIssuesAndUpdate(\n      ANGLE_CONDITIONS.precondition,\n      ANGLE_CONDITIONS.postcondition,\n      (input) => Math.PI / 256 * input,\n      e.target.value,\n      0\n    );\n    this.setState({angulardelta: actualAngle});\n  }\n\n  handleScaleUpdate(e) {\n    let actualScale = this.checkForInputIssuesAndUpdate(\n      SCALE_CONDITIONS.precondition,\n      SCALE_CONDITIONS.postcondition,\n      (input) => input * 0.01,\n      e.target.value,\n      1\n    );\n    this.setState({scale: actualScale});\n  }\n\n  /**\n   * Check whether the current inputs are problematic and flag/construct error string if they are\n   * Returns result of operation if no issues, default value o/w\n   * \n   * @param {object} preCond has validate to check inputs and errmsg, a log string\n   * @param {object} postCond has validate to check inputs and errmsg, a log string\n   * @param {function} inputOp operation to perform on input if it passed precond\n   * @param {*} input  input to input op\n   * @param {*} defaultValue default value to return on errors\n   */\n  checkForInputIssuesAndUpdate(preCond, postCond, inputOp, input, defaultValue) {\n    if (this.handleAndFlagIssues(preCond, input)) {\n      return defaultValue;\n    }\n    let tempResult = inputOp(input);\n    if (this.handleAndFlagIssues(postCond, tempResult)) {\n      return defaultValue;\n    }\n    return tempResult;\n  }\n\n  /**\n   * \n   * @param {object} criteria object with validate to check inputs, and an error string\n   * @param {*} value value to call validate on\n   * @returns whether the value meets the criteria\n   */\n  handleAndFlagIssues(criteria, value) {\n    let hasFailed = criteria.validate(value)\n    if (hasFailed) {\n      this.inputIssues.add(criteria.errmsg);\n    } else {\n      this.inputIssues.delete(criteria.errmsg);\n    }\n    return hasFailed;\n  }\n\n  getCachedCanvas() {\n    if (!this.cachedCanvas) {\n      this.cachedCanvas = document.getElementById(CANVASID);\n    }\n\n    return this.cachedCanvas;\n  }\n\n  initCoords() {\n    this.clearCanvas();\n    // generate new initial coords\n    this.origcoords = PTS_GENERATORS[this.state.pointdist](this.state.pts);\n    this.handleDrawing();\n  }\n\n  clearCanvas() {\n    let canvas = this.getCachedCanvas();\n    if (canvas.getContext) {\n      let cnx = canvas.getContext('2d');\n      this.clear(cnx);\n    }\n  }\n\n  handleDrawing() {\n    let canvas = this.getCachedCanvas();\n    if (canvas.getContext) {\n      let cnx = canvas.getContext('2d');\n      this.draw(cnx);\n      this.currentDelta += this.state.angulardelta;\n      this.currentScale *= this.state.scale;\n    }\n  }\n\n  clear(canvasContext) {\n    canvasContext.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n    this.currentDelta = 0;\n    this.currentScale = 1;\n  }\n\n  draw(canvasContext) {\n    canvasContext.save();\n    canvasContext.fillStyle = 'rgb(40, 40, 100, 255)';\n    canvasContext.translate(CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2);\n    canvasContext.scale(this.currentScale, this.currentScale);\n    canvasContext.rotate(this.currentDelta);\n    canvasContext.translate(-CANVAS_WIDTH / 2, -CANVAS_HEIGHT / 2);\n    for (let toDraw of this.origcoords) {\n      canvasContext.fillRect(toDraw.x, toDraw.y, OBJ_WIDTH, OBJ_HEIGHT);\n    }\n    canvasContext.restore();\n  }\n\n  render() {\n    return (\n      <div className=\"canvas-container\">\n        <canvas id={CANVASID} width={CANVAS_WIDTH} height={CANVAS_HEIGHT}>\n          Canvas appears to be unsupported :(\n        </canvas>\n        <ErrorGroup errorList={[...this.inputIssues]}/>\n        <div id=\"spiral-canvas-controls\">\n          <select id=\"distribution\" onChange={this.handleDistUpdate}>\n            <option value=\"random\">Random Distribution</option>\n            <option value=\"uniform\">Uniform Distribution</option>\n            <option value=\"uniformVar\">Uniform Distribution with random variance</option>\n          </select>\n          <input type=\"range\" id=\"spiralpoints\" min=\"1\" max={MAX_POINTS_ALLOWED} onChange={this.handlePointCountUpdate}/>\n          <label htmlFor=\"spiralpoints\">Number of Points</label>\n          <input id=\"angle\" onChange={this.handleAngleUpdate}/>\n          <label>Change in Angle (currently: {this.state.angulardelta} radians; The given value is in steps of π/256)</label>\n          <input id=\"scaling\" onChange={this.handleScaleUpdate}/>\n          <label>Scaling Factor (in percent of previous)</label>\n          <button className=\"btn equalbtn\" disabled={this.inputIssues.size !== 0} onClick={this.handleDrawing}>Draw More</button>\n        </div>\n      </div>\n    )\n  }\n}\n\nexport default Spiral;","import React from 'react';\nimport * as utils from '../Utils.js';\nimport '../style/drawtrial.css';\nimport '../style/commondraw.css';\n\nconst CANVASID = \"swarm-canvas\"\nconst CANVAS_WIDTH = 512;\nconst CANVAS_HEIGHT = 512;\nconst OBJ_WIDTH = 8;\nconst OBJ_HEIGHT = 8;\nconst MAX_SPEED = 10;\nconst MAX_POINTS_ALLOWED = 64;\nconst LOGISTIC_STEEPNESS = 0.05;\nconst LOGISTIC_MIDPOINT = 50; // in pixels\nconst PTS_GENERATORS = {\n  random: randGenerator,\n  uniformVar : uniformGeneratorWithVariance\n}\n\nclass Agents extends React.Component {\n  constructor(props) {\n    super(props);\n    // canvas can handle most things on its own\n    this.state = {\n      pointdist: 'random',\n      attrepthreshold: LOGISTIC_MIDPOINT,\n      attrepforce: MAX_SPEED / 2,\n      pts: 32,\n    };\n    this.handleAttRepThresholdUpdate = this.handleAttRepThresholdUpdate.bind(this);\n    this.handleAttRepForceUpdate = this.handleAttRepForceUpdate.bind(this);\n    this.handleDistUpdate = this.handleDistUpdate.bind(this);\n    this.handlePointCountUpdate = this.handlePointCountUpdate.bind(this);\n    this.timeId = -1;\n    this.cachedCanvas = null;\n    this.coords = [];\n  }\n\n  componentDidMount() {\n    this.timeId = setInterval(\n      () => this.tick(),\n      75\n    );\n    this.initCoords();\n  }\n\n  componentDidUpdate() {\n    this.initCoords();\n  }\n\n  componentWillUnmount() {\n    clearInterval(this.timeId);\n  }\n\n  handleAttRepThresholdUpdate(e) {\n    this.setState({attrepthreshold: e.target.value});\n  }\n\n  handleAttRepForceUpdate(e) {\n    this.setState({attrepforce: e.target.value});\n  }\n\n  handleDistUpdate(e) {\n    this.setState({pointdist: e.target.value});\n  }\n\n  handlePointCountUpdate(e) {\n    this.setState({pts: e.target.value});\n  }\n\n  tick() {\n    if (!this.cachedCanvas) {\n      this.cachedCanvas = document.getElementById(CANVASID);\n    }\n\n    let canvas = this.cachedCanvas;\n    if (canvas.getContext) {\n      let cnx = canvas.getContext('2d');\n      this.draw(cnx);\n      this.updateCoords();\n      this.updateV();\n    }\n  }\n\n  draw(canvasContext) {\n    canvasContext.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n    for (let toDraw of this.coords) {\n      canvasContext.save();\n      canvasContext.fillStyle = \n        'rgb(' + toDraw.yv * 20 + ', ' + toDraw.xv * 20 + ', 100, 100)';\n      canvasContext.translate(toDraw.x, toDraw.y);\n      canvasContext.fillRect(0, 0, OBJ_WIDTH, OBJ_HEIGHT);\n      canvasContext.restore();\n    }\n  }\n\n  updateV() {\n    for (let i = 0; i < this.coords.length; i++) {\n      // is this optimal?\n      let otherCoord = this.coords.slice();\n      let newCoord = otherCoord.splice(i, 1)[0];\n      let forces = this.forceApplied(otherCoord, newCoord);\n\n      newCoord.xv += forces.xapplied;\n      newCoord.yv += forces.yapplied;\n      newCoord.xv = Math.abs(newCoord.xv) > MAX_SPEED ? Math.sign(newCoord.xv) * MAX_SPEED : newCoord.xv;\n      newCoord.yv = Math.abs(newCoord.yv) > MAX_SPEED ? Math.sign(newCoord.yv) * MAX_SPEED : newCoord.yv;\n      this.coords[i] = newCoord;\n    }\n  }\n\n  /**\n   * find forces that should be applied to this point\n   * @param {Object} currentcoord\n   * @param {list} otherCoords \n   */\n  forceApplied(otherCoords, currentcoord) {\n    // use an accumulator instead? TODO\n    let currentXApplied = 0;\n    let currentYApplied = 0;\n    for (let coord of otherCoords) {\n      let xdelta = (currentcoord.x - coord.x);\n      let ydelta = (currentcoord.y - coord.y);\n\n      if(xdelta === 0 && ydelta === 0) {\n        console.log(\"Point Overlap\");\n        continue;\n      }\n\n      let distsqrd = Math.pow(xdelta, 2) + Math.pow(ydelta, 2);\n      let magnitude = this.logistic(Math.sqrt(distsqrd), this.state.attrepforce);\n      let angleRep = Math.abs(Math.atan(ydelta/xdelta));\n\n      // repelling when close, attracting o/w\n      let xdirection = Math.sqrt(distsqrd) < this.state.attrepthreshold ? Math.sign(xdelta) : - Math.sign(xdelta);\n      let ydirection = Math.sqrt(distsqrd) < this.state.attrepthreshold ? Math.sign(ydelta) : - Math.sign(ydelta);\n\n      currentXApplied += xdirection * (magnitude * Math.cos(angleRep));\n      currentYApplied += ydirection * (magnitude * Math.sin(angleRep));\n    }\n\n    return {\n      xapplied: Math.round(currentXApplied),\n      yapplied: Math.round(currentYApplied)\n    }\n  }\n\n  logistic(x, max) {\n    return max / (1 + Math.exp(LOGISTIC_STEEPNESS * (x - LOGISTIC_MIDPOINT)));\n  }\n\n  // TODO this should be some sort of common func\n  updateCoords() {\n    for (let toUpdate of this.coords) {\n      // handle movement including partial movement\n      toUpdate.x += toUpdate.xv;\n      toUpdate.y += toUpdate.yv;\n\n      // edge collision\n      if (toUpdate.x > CANVAS_WIDTH - OBJ_WIDTH) {\n        toUpdate.x = CANVAS_WIDTH - OBJ_WIDTH;\n      } else if (toUpdate.x < 0) {\n        toUpdate.x = 0;\n      }\n\n      if (toUpdate.y > CANVAS_HEIGHT - OBJ_HEIGHT) {\n        toUpdate.y = CANVAS_HEIGHT - OBJ_HEIGHT;\n      } else if (toUpdate.y < 0) {\n        toUpdate.y = 0;\n      }\n    }\n  }\n\n  initCoords() {\n    this.coords = PTS_GENERATORS[this.state.pointdist](this.state.pts);\n  }\n\n  render() {\n    return (\n      <div className=\"canvas-container\">\n        <canvas id={CANVASID} width={CANVAS_WIDTH} height={CANVAS_HEIGHT}>\n          Canvas appears to be unsupported :(\n        </canvas>\n        <div id=\"canvas-controls\">\n          <input type=\"range\" id=\"points\" min=\"2\" max={MAX_POINTS_ALLOWED} onChange={this.handlePointCountUpdate}/>\n          <label htmlFor =\"points\">Number of Points</label>\n          <input type=\"range\" id=\"threshold\" min={LOGISTIC_MIDPOINT / 2} max={LOGISTIC_MIDPOINT * 2} onChange={this.handleAttRepThresholdUpdate}/>\n          <label htmlFor =\"threshold\">Attraction/Repulsion Distance Threshold</label>\n          <input type=\"range\" id=\"force\" min=\"0\" max={MAX_SPEED} onChange={this.handleAttRepForceUpdate}/>\n          <label htmlFor =\"force\">Attraction/Repulsion Force</label>\n          <select id=\"distribution\" onChange={this.handleDistUpdate}>\n            <option value=\"random\">Random Distribution</option>\n            <option value=\"uniformVar\">Uniform Distribution with random variance</option>\n          </select>\n        </div>\n      </div>\n    )\n  }\n}\n\nfunction randGenerator(pointsToGen) {\n  let newCoords = [];\n  for (let i = 0; i < pointsToGen; i++) {\n    newCoords.push({\n      x: utils.randomInt(CANVAS_WIDTH - OBJ_WIDTH),\n      y: utils.randomInt(CANVAS_HEIGHT - OBJ_HEIGHT),\n      xv: 0,\n      yv: 0\n    });\n  }\n  return newCoords;\n}\n\nfunction uniformGeneratorWithVariance(pointsToGen) {\n  let rawcoords = utils.uniformBaseGenerator(pointsToGen, (step) => utils.randomIntEitherSign(step/4),\n   CANVAS_HEIGHT, CANVAS_WIDTH);\n  return rawcoords.map(coordsToCoordsWithVelocity);\n}\n\n/**\n * Adapter to turn coordinates with just x & y into coordinates\n *  with position and velocity\n */\nfunction coordsToCoordsWithVelocity(baseCoord) {\n  return {\n    x: baseCoord.x,\n    y: baseCoord.y,\n    xv: 0,\n    yv: 0\n  }\n}\n\nexport default Agents;","import React from 'react';\nimport TEMPLATES from './phrasebook/FullPhrasePicker.js'\nimport PhraseTemplate from './phrasebook/PhraseTemplate.js'\nimport DrawTrial from './movingparts/DrawTrial.js'\nimport Spiral from './movingparts/Spiral.js'\nimport Agents from './movingparts/Agents.js'\nimport './App.css';\n\n/**\n * Props are applications: list of applications containing objs that have\n * title, content and description\n */\nclass ApplicationPicker extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {active : 0}\n    this.pickActiveApp = this.pickActiveApp.bind(this);\n    this.nextApp = this.nextApp.bind(this);\n    this.previousApp = this.previousApp.bind(this);\n  }\n\n  pickActiveApp() {\n    return this.props.applications[this.state.active];\n  }\n\n  nextApp() {\n    let newActive = this.state.active + 1 > this.props.applications.length - 1\n    ? 0\n    : this.state.active + 1;\n    this.setState({\n      active: newActive\n    });\n  }\n\n  previousApp() {\n    let newActive = this.state.active - 1 < 0\n    ? this.props.applications.length - 1\n    : this.state.active - 1;\n    this.setState({\n      active: newActive\n    });\n  }\n\n  render() {\n    return (\n      <>\n      <div id=\"topbar\">{this.pickActiveApp().title}\n        <div id=\"selectors\">\n          <button className=\"btn equalbtn\" onClick={this.previousApp}>Previous</button>\n          <button className=\"btn equalbtn\" onClick={this.nextApp}>Next</button>\n        </div>\n      </div>\n      {this.pickActiveApp().content}\n      <div id=\"botbar\">What is this? \n        <div id=\"desc\">{this.pickActiveApp().description}</div>\n      </div>\n      </>\n    )\n  }\n}\n\nfunction App() {\n\n  return (\n    <div id=\"backbox\">\n      <ApplicationPicker applications={appPicker}/>\n    </div>\n  );\n}\n\nconst agent = {\n  title: \"Independent Agents\",\n  content: <Agents/>,\n  description: \"Trying even more random stuff with the canvas.\" +\n  \" Playing around with having each point act independently in a sorta swarm-like way\"\n}\n\nconst spiral = {\n  title: \"Moiré Effect\",\n  content: <Spiral/>,\n  description: \"Trying more random stuff with the canvas.\" +\n  \" \\\"That's a Moiré\\\"\"\n}\n\nconst drawTrial = {\n  title: \"Canvas Trial\",\n  content: <DrawTrial/>,\n  description: \"Trying random stuff with the canvas. Looks kinda cool, I guess. \" +\n  \"There is a slight variance to the angle they go off in, so it eventually degenerates into a cloud.\" +\n  \"Some strangeness might occur as roundoff makes stuff imprecise\"\n}\n\nconst abilityGen = {\n  title: \"Random Terrible Ability Generator\",\n  content: <PhraseTemplate isTop={true} template={TEMPLATES} canBeRerolled={false}/>,\n  description: \"Generate silly random ability ideas. Click on highlighted words to reroll them\" \n}\n\nconst welcome = {\n  title: \"Gallery of Meaningless Creations\",\n  content: <></>,\n  description: \"Collection of random pointless things. Not useful, but I still love them. \" + \n  \"This is a welcome page, so there is nothing here. \" + \n  \"Use the buttons at the top to look through what there is!\" \n}\n\nconst appPicker = [\n  welcome,\n  abilityGen,\n  drawTrial,\n  spiral,\n  agent\n]\n\nexport default App;","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}